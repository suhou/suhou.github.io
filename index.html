<!doctype html>



  


<html class="theme-next muse use-motion">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1">






<meta property="og:type" content="website">
<meta property="og:title" content="su">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="su">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="su">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/">

  <title> su </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">su</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/05/21/从一个crash体验strong的延迟释放/" itemprop="url">
                  从一个crash体验strong的延迟释放
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2019-05-21T17:42:28+08:00" content="2019-05-21">
              2019-05-21
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>文章的标题看上去有点唬人, 毕竟strong作为iOS开发中一个基础的不能再基础的语义声明, 有什么好讲的… </p>
<p>事实上本文源自于前文<a href="https://suhou.github.io/2019/05/14/%E4%BB%8E%E4%B8%80%E4%B8%AAcrash%E7%90%86%E8%A7%A3weak%E7%9A%84%E5%BB%B6%E8%BF%9F%E9%87%8A%E6%94%BE/" target="_blank" rel="noopener">从一个crash理解weak的延迟释放</a>写完之后与小伙伴的讨论, 既然如此我们先简单回顾一下.</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在前文中, 我们在文章末尾给出了一个demo, 模拟笔者在项目中的crash.<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) Manager *strongManager;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) Operation *strongOperation;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="built_in">UIButton</span> *btn = [[<span class="built_in">UIButton</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>)];</span><br><span class="line">    [btn setBackgroundColor:[<span class="built_in">UIColor</span> redColor]];</span><br><span class="line">    [btn addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(btnAction:) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:btn];</span><br><span class="line">    <span class="comment">// 模拟网络请求</span></span><br><span class="line">    <span class="keyword">self</span>.strongManager = [Manager new];</span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">self</span>.strongManager.endBlock = ^&#123;</span><br><span class="line">        weakSelf.strongManager = <span class="literal">nil</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.strongOperation = [Operation new];</span><br><span class="line">    [<span class="keyword">self</span>.strongOperation setTarget:<span class="keyword">self</span>.strongManager selector:<span class="keyword">@selector</span>(testMethod)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)btnAction:(<span class="keyword">id</span>)sender&#123;</span><br><span class="line">    [<span class="keyword">self</span>.strongOperation performCallBack]; <span class="comment">// &lt;- 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Manager</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="keyword">void</span>(^endBlock)(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)testMethod;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Manager</span></span></span><br><span class="line">- (<span class="keyword">void</span>)testMethod&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.endBlock) &#123;</span><br><span class="line">        <span class="keyword">self</span>.endBlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"dealloc"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Operation</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span> target;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>)SEL finishSelector;</span><br><span class="line">- (<span class="keyword">void</span>)setTarget:(<span class="keyword">id</span>)target selector:(SEL)selector;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)performCallBack;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Operation</span></span></span><br><span class="line">- (<span class="keyword">void</span>)setTarget:(<span class="keyword">id</span>)target selector:(SEL)selector&#123;</span><br><span class="line">    <span class="keyword">self</span>.target = target;</span><br><span class="line">    <span class="keyword">self</span>.finishSelector = selector;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)performCallBack&#123;</span><br><span class="line">    <span class="built_in">NSMethodSignature</span> *signature = [<span class="keyword">self</span>.target methodSignatureForSelector:<span class="keyword">self</span>.finishSelector];</span><br><span class="line">    <span class="built_in">NSInvocation</span> *invocation = [<span class="built_in">NSInvocation</span> invocationWithMethodSignature:signature];</span><br><span class="line">    [invocation setTarget:<span class="keyword">self</span>.target];</span><br><span class="line">    [invocation setSelector:<span class="keyword">self</span>.finishSelector];</span><br><span class="line">    [invocation invoke];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>在位置<code>1</code>处模拟网络请求回来进行回调, 然后crash, 原因如前文所说这是没有任何问题的. 然而前文中还有一张图<br><img src="/pics/wildpointer.003.jpeg" alt="野指针" title="野指针"><br>可以看到上面给出的demo其实是对图里的过程进行了简化, 所以来看一看正常按照图上写的话demo应该是什么样子.<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) Manager *manager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">//正常写代码的时候还是推荐使用self.debugObj这种形式, 这里是为了排除干扰因素于是全部是用ivar的方式</span></span><br><span class="line">    _manager = [Manager new];</span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    _manager.testBlock = ^&#123;</span><br><span class="line">        weakSelf.manager = <span class="literal">nil</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//发起网络请求</span></span><br><span class="line">    [<span class="keyword">self</span>.manager networkRequest]; <span class="comment">//&lt;- 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Manager</span><br><span class="line">.h略过</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Manager</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"dealloc"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)networkRequest &#123;</span><br><span class="line">    Operation *operation = [Operation new];</span><br><span class="line">    operation.target = <span class="keyword">self</span>;</span><br><span class="line">    operation.selector = <span class="keyword">@selector</span>(networkCallBack);</span><br><span class="line">    [operation performCallback];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// call back</span></span><br><span class="line">- (<span class="keyword">void</span>)networkCallBack &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.testBlock) &#123;</span><br><span class="line">        <span class="keyword">self</span>.testBlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Operation .h .m</span><br><span class="line">和文章开头demo中的operation一样</span><br></pre></td></tr></table></figure>
<p>这个demo在代码<code>2</code>的位置模拟网络请求, 网络请求封装在<code>manager</code>中, 事实上, 项目代码里的网络请求也是这么写的, 唯一的不一样地方在于<strong><code>networkCallBack</code>方法在这里是同步调用, 而正常项目中网络请求是异步回来的</strong>. 然后有意思的地方就来了, 可能大家都能猜到, 上面这个demo中这样并不会crash…</p>
<h2 id="追根溯源"><a href="#追根溯源" class="headerlink" title="追根溯源"></a>追根溯源</h2><p>于是开启大家来找茬模式, 仔细比对两份代码不同的地方, demo其实只做了一件事,在代码位置<code>2</code>处通过<code>mananger</code>的getter方法来获取对象然后调用<code>networkRequest</code>方法, 而<code>networkRequest</code>中一系列操作会将<code>manager</code>销毁.<br>在位置<code>2</code>处尝试把<code>self.manager</code>改为<code>_manager</code>, 成功的触发野指针crash.<br><del>于是笔者一开始很容易的就认为, <code>self.manager</code>所调用的getter方法在return的时候为返回的对象加了autorelease操作, 导致manager对象在置为nil后还能存活</del><br>然鹅, 在这个demo中, <code>manager</code>对象<code>dealloc</code>的时候调用栈里并没有autorelease销毁的调用栈…所以上面那个结论其实是不成立的.<br>于是想到看一看这两种调用到底有什么差别, 把这两种写法的汇编拉出来看一看:<br><img src="/pics/property_getter.png" alt="property getter" title="property getter"><br><img src="/pics/property_ivar.png" alt="property ivar" title="property ivar"><br>第一张图是通过getter拿到对象的写法, 可以清晰的看到这种写法多了<strong><code>_objc_retainAutoreleasedReturnValue</code>和<code>_objc_release</code></strong>两个操作.<br>而getter方法中实际上的操作是:<br><img src="/pics/manager_getter.png" alt="manager getter" title="manager getter"><br>之前笔者认为getter方法在return的时候会调用<code>objc_autoreleaseRturnValue</code>, 可是这里很清楚显示调用的是<code>_objc_retainAutoreleaseReturnValue</code>, 实际上, 如果没有重写getter方法的话, 这句话都不会加.<br>那么问题就很简单了, 看一看这几个操作的作用是什么就好了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// Prepare a value at +0 for return through a +0 autoreleasing convention.</span><br><span class="line">id </span><br><span class="line">objc_retainAutoreleaseReturnValue(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    if (prepareOptimizedReturn(ReturnAtPlus0)) return obj;</span><br><span class="line"></span><br><span class="line">    // not objc_autoreleaseReturnValue(objc_retain(obj)) </span><br><span class="line">    // because we don&apos;t need another optimization attempt</span><br><span class="line">    return objc_retainAutoreleaseAndReturn(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Accept a value returned through a +0 autoreleasing convention for use at +1.</span><br><span class="line">id</span><br><span class="line">objc_retainAutoreleasedReturnValue(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    if (acceptOptimizedReturn() == ReturnAtPlus1) return obj;</span><br><span class="line"></span><br><span class="line">    return objc_retain(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不同版本里的<code>runtime</code>里对这几个函数的实现可能不太一样, 但是大概的意思是一样的, 这里摘抄的版本是<code>objc4-709</code>. 这里关键的函数<code>objc_retainAutoreleasedReturnValue</code>也就是前文中使用getter方式比ivar方式多的两部操作之一里面大概做了这么一件事, 它会与<code>objc_autoreleaseReturnValue</code>配合, 如果在返回值身上调用<code>objc_autoreleaseReturnValue</code>, 这个返回值会先被存储在TLS中, 然后外部接收方调用<code>objc_retainAutoreleasedReturnValue</code>时, 发现TLS中正好存了这个对象便直接返回这个对象, 从而减去存入autorelesepool的过程, 这一TLS优化在《Objective-C高级编程 iOS与OS X多线程和内存管理》一书中有一定篇幅的解释.<br>我们这里则是走入了没有优化的分支语句中, 也就是<code>return objc_retain(obj);</code>, 然后在<code>_objc_msgSend</code>之后调用的<code>_objc_release</code>. 这下就全明白了, 也就是说使用getter方法进行对象方法调用的时候, 编译器和<code>runtime</code>会帮我们悄咪咪的把对象引用计数+1, 在方法调用结束以后再减一. 这样一来我们这个方法在同步调用的时候就不用担心在同步的调用中因为对象被释放而引发野指针, 因为就算当前同步调用中当前对象实际持有者‘释放’了它, 在方法调用结束前还有runtime悄悄的给它+1s, 也就是文章标题中所说的延迟释放.<br>回到crash上面, 前面说到上面的demo中和实际项目中的区别是demo中是同步的, 而项目中是是异步的, 网络请求回调回来的时候<code>networkRequest</code>已经走完了, 也就是<code>runtime</code>中增加的引用计数已经释放了, 那么自然在实际项目中就crash了.<br>只聚焦这个问题的话,其实答案已经给出了, 不过依然还有很多值得探索, 例如本文提到其它几个函数里都做了些啥, 例如什么时候在return的时候会加上<code>objc_autoreleaseReturnValue</code>(通过汇编看是在return一个局部变量的时候). 如果重写demo里ViewController的manager getter方法的话, 又会有惊喜. 深入的话需要大量篇幅, 所以先用这张经典的图收尾吧…<br><img src="/pics/MemoryPic.png" alt="Memory" title="Memory"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>惯例总结一下:</p>
<ol>
<li>警惕在对象持有的block中释放该对象本身这种代码<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">weakSelf.manager.testBlock = ^&#123;</span><br><span class="line">        weakSelf.manager = <span class="literal">nil</span>;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>出现这种代码的时候想一想在使用过程中有没有可能出现文中类似情况.</p>
<ol start="2">
<li>解释一段代码为什么没有问题可能比解释一段代码为什么有问题更加困难. 编译器和<code>runtime</code>以及<code>Runloop</code>为开发者的代码提供了很多的优化, 除了文中说到的引用计数增减以外还有autoreleasepool的运用, 所以开发过程中能遵守原本的内存管理语义就尽量遵守, 笔者所在的团队代码checkList中有一条是强调除了几个特定的方法中使用ivar方式访问变量, 其它都是用self.xxx的方式访问, 这样子的规范其实就避免了本文第二个demo中的crash.</li>
<li>最后给出一个简化的demo, 比上面那两个还要简化, 方便观察</li>
<li>本文中如果有说的不对的地方, 欢迎大家及时指出来.<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><a href="https://www.galloway.me.uk/2012/02/how-does-objc_retainautoreleasedreturnvalue-work/" target="_blank" rel="noopener">How does objc_retainAutoreleasedReturnValue work?</a><br><a href="https://www.mikeash.com/pyblog/friday-qa-2011-09-30-automatic-reference-counting.html" target="_blank" rel="noopener">Friday Q&amp;A 2011-09-30: Automatic Reference Counting</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/05/14/从一个crash理解weak的延迟释放/" itemprop="url">
                  从一个crash理解weak的延迟释放
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2019-05-14T20:36:07+08:00" content="2019-05-14">
              2019-05-14
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="crash"><a href="#crash" class="headerlink" title="crash"></a>crash</h2><p>最近在项目内部碰到一个野指针crash, 说起来这个crash也很简单, 就是一个在声明一个对象的时候用的是assign, 然后对象释放了还继续调用改对象的方法就crash了. 先来看一个最简单的野指针示意图<br><img src="/pics/wildpointer.001.jpeg" alt="野指针1" title="野指针1"><br>A对C对像是强持有, B对C对象的申明是assign, 当A释放了C以后, B在调用C的xxx方法就会野指针crash. 对于开发者来说, 很少会把对象申明成assign, 所以这种写法引发的crash是比较好排查的, 下面看另一种示意图.<br><img src="/pics/wildPointer.002.jpeg" alt="野指针2" title="野指针2"><br>这里B对D是弱引用, C对D是assign引用, 笔者这里示意图里想表明的是C其实是通过B的某些调用才触发对assign对象D的方法调用, 同样的原因唯一对D强引用的A如果在这个过程中释放了D就会造成crash, 说到这里可能会问, 什么场景需要这么费劲的调用, 看上去B也可以直接对D进行调用而且weak不会造成野指针不是吗. 还原一下当时的crash场景.<br><img src="/pics/wildpointer.003.jpeg" alt="野指针3" title="野指针3"><br>简单说就是A对象通过一个manager(或者viewModel之类的),发出一个网络请求, 图2中的B在这个场景中其实是一个网络库, manager是网络请求的delegate, 负责网络请求之后的回调, 这个网络库在设计的时候为了扩展性考虑在触发回调的时候使用了一个NSInvocation. 关键代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@interface SSHttpOperation()</span><br><span class="line">...</span><br><span class="line">//网络回调的target</span><br><span class="line">@property(nonatomic, weak)id target;</span><br><span class="line">//外部在发网络请求的时候可以随意设置回调方法, 达到扩展性</span><br><span class="line">@property(nonatomic, assign)SEL didFinishSelector;</span><br><span class="line">...</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation SSHttpOperation</span><br><span class="line">- (void)notifyWithResult:(NSDictionary*)result error:(NSError*)error continueWhenCancel:(BOOL)continueWhenCancel &#123;</span><br><span class="line">	//网络请求回来, 进行外部业务回调</span><br><span class="line">    ...</span><br><span class="line">       if(target &amp;&amp; [target respondsToSelector:didFinishSelector])  &#123;</span><br><span class="line">           NSMethodSignature *signature = [target methodSignatureForSelector:didFinishSelector];</span><br><span class="line">           NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:signature];</span><br><span class="line">           [invocation setTarget:target]; // 1</span><br><span class="line">           [invocation setSelector:didFinishSelector];</span><br><span class="line">           id wself = self;</span><br><span class="line">           [invocation setArgument:&amp;wself atIndex:2];</span><br><span class="line">           [invocation setArgument:&amp;result atIndex:3];</span><br><span class="line">           [invocation setArgument:&amp;logicError atIndex:4];</span><br><span class="line">           [invocation setArgument:&amp;userInfo atIndex:5];</span><br><span class="line">           [invocation invoke];</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>网络库Operation的<code>关键</code>代码其实就是这个, 代码<code>1</code>的位置<code>[invocation setTarget:target]</code>, 点开<code>NSInvocation.h</code>的头文件可以看到<code>NSInvocation</code>对<code>target</code>的申明是assign…<br>再简单看一下外部是怎么操作的引起crash:<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Object A</span><br><span class="line"></span><br><span class="line">[self.pgcActionManager changePGCAccount:mediaID likeStatus:!hasSubscribed extraTrack:extraTrack likeBlock:^(BOOL isLiked, NSError *error, NSArray&lt;TTVUserAccount *&gt; *recommendUsers) &#123;</span><br><span class="line">       // 一堆业务操作 再block的最后把这个manager置为nil</span><br><span class="line">       ...</span><br><span class="line">       self.pgcActionManager = nil; // 2</span><br><span class="line">   &#125;];</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Manager</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">- (void)changePGCAccount:(NSString *)mediaID likeStatus:(BOOL)changeToLike likeBlock:(SSPGCActionManagerLikeBlock)likeBlock&#123;</span><br><span class="line">	...</span><br><span class="line">	self.likeOperation = [SSHttpOperation httpOperationWithURLString:url getParameter:nil postParameter:parameterDict userInfo:userInfo];</span><br><span class="line">    [_likeOperation setQueuePriority:NSOperationQueuePriorityHigh];</span><br><span class="line">    [_likeOperation setFinishTarget:self selector:@selector(operation:finishedResult:error:userInfo:)];</span><br><span class="line">    [SSOperationManager addOperation:_likeOperation];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 网络回调</span><br><span class="line">- (void)operation:(SSHttpOperation*)operation finishedResult:(NSDictionary*)result error:(NSError*)error userInfo:(id)userInfo&#123;</span><br><span class="line"> // 业务逻辑代码 xxx</span><br><span class="line"> //3</span><br><span class="line"> if (_likeBlock) &#123;</span><br><span class="line">	  _likeBlock(isFollow, followError, recommendUsersArray);</span><br><span class="line">   &#125;</span><br><span class="line"> // 后续的业务逻辑代码</span><br><span class="line"> // 4</span><br><span class="line"> [TTVLoginManager showLoginForFollowWithResult:@&quot;你的关注太多,登录保存一下吧&quot; extraTrackDic:@&#123;@&quot;isOver&quot;:@(1)&#125; position:self.position];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面摘抄了一些关键代码, 调用顺序大概是:<br>Object A业务逻辑触发了[Manager changePGCAccount…]方法<br>-&gt; Manager通过网络库发请求并通过NSInvocation触发回调<code>(代码1)</code><br>-&gt; 回调方法执行likeBlock<code>(代码3)</code><br>-&gt; block内Object A释放Manager<code>(代码2)</code>, Manager dealloc方法也在此时执行<br>-&gt; likeBlock执行完后由于业务需求调用了self.position<code>(代码4)</code>, 崩擦擦.</p>
<h2 id="weak"><a href="#weak" class="headerlink" title="weak"></a>weak</h2><p>至此我们找到了crash的原因, 修改的方法有很多, 上面我们有说到Operation对Manager其实是弱引用的, 只是为了扩展性?(大概)才通过NSInvocation调用本该是自己的delagte回调, 其实如果牺牲一点扩展性在现在代码的使用<code>NSInvocation</code>的位置<code>(代码1)</code>替换成<code>[self.target xxxx]</code>就不会出问题了, 事实上现在我们大部分的代理在使用过程中也是这个思路.<br>事实证明,直接调确实是没有问题的, 并且有一个有意思的现象, 通过这种调用在<code>(代码2)self.pgcActionManager = nil;</code>的时候, 这个Manager没有立即走dealloc, 也就是并没有立即释放, 换句话说, 还有别人在持有这个Manager? 一个常识是weak修饰的对象会在对象释放之后置为nil, 但是这和被修饰对象不立即释放并没有什么关系.<br>于是想到了《Objective-C高级编程 iOS与OS X多线程和内存管理》一书里提到过的,weak会将被修饰对象加入autoreleasePool达到延迟释放的效果, 笔者在读这一段的时候做过诸多实验, 最后的结论是对这个说法表示怀疑, 但是现在看确实是有延迟释放的效果. 直接看答案吧<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  id __weak obj1 = obj;</span><br><span class="line">  NSLog(@&quot;%@&quot;, obj1);</span><br><span class="line">&#125;</span><br><span class="line">/* iOS5及之前编译器做法 */</span><br><span class="line">id obj1;</span><br><span class="line">objc_initWeak(&amp;obj1, obj);</span><br><span class="line">id tmp = objc_loadWeakRetained(&amp;obj1);</span><br><span class="line">objc_autorelease(tmp);//错误!!!mistake</span><br><span class="line">NSLog(@&quot;%@&quot;, tmp);</span><br><span class="line">objc_destroyWeak(&amp;obj1);</span><br><span class="line"></span><br><span class="line">/* 现在的编译器做法*/</span><br><span class="line">id obj = objc_msgSend(NSObject, &quot;new&quot;);</span><br><span class="line">id obj1;</span><br><span class="line">objc_initWeak(&amp;obj1, obj);</span><br><span class="line">id tmp = objc_loadWeakRetained(obj1);//objc_loadWeakRetained would increment the reference count to ensure that tmp is alive in the NSLog statement.</span><br><span class="line">NSLog(@&quot;%@&quot;, obj1);</span><br><span class="line">objc_release(tmp);</span><br><span class="line">objc_destroyWeak(&amp;obj1);</span><br><span class="line">objc_storeStrong(&amp;obj, 0);//release</span><br></pre></td></tr></table></figure></p>
<p>现在的编译器在我们使用weak对象的时候会帮我们插入<code>objc_loadWeakRetained</code>导致weak对象引用计数+1, 达到在使用weak对象的时候改对象永远不可能被释放, 在我们的case中就是<code>[self.target xxxx]</code>这个<code>xxx</code>方法中即使将有代码将<code>target</code>释放了, 表面上看引用计数好像为0了, 应该释放, 事实上只有在这个方法走完了引用计数才有可能清0. 以前知道这个实现, 但是没注意这个特性, 现在看只想说奈斯 兄dei.</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>最后总结一下这次改bug的收获:</p>
<ol>
<li>NSInvocation是有可能引起野指针的, 使用的时候要多加小心, 尤其是在基础库中的使用.当然就正常使用规范来说文中的那个likeBlock应该放在方法末尾执行(这样也不会crash), 只是业务需要在block执行后继续执行一些操作.</li>
<li>weak会通过objc_loadWeakRetained函数被修饰对象引用计数+1, 保证对象在正在使用的过程中不被释放, 这也是和assign非常不一样一个点.</li>
<li>一些代码设计上的收获, 例如在设计基础库的时候对扩展性和稳定性的取舍, 不展开了.</li>
</ol>
<h2 id="最后的最后"><a href="#最后的最后" class="headerlink" title="最后的最后"></a>最后的最后</h2><p>撰写本文的过程中尝试过用clang命令rewrite源码, 期间由于没有运行时环境支持开始一直报错, 现在附上一个iOS系统下的clang命令, 供有兴趣的读者参考:<br>xcrun -sdk iphonesimulator clang -rewrite-objc -fobjc-arc -stdlib=libc++ -mios-version-min=12.1 -fobjc-runtime=ios-12.1 -Wno-deprecated-declarations ViewController.m</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h2><p><a href="https://github.com/SenorSamuel/blog/issues/5" target="_blank" rel="noopener">Objective-C高级编程</a><br><a href="https://stackoverflow.com/questions/40993809/why-weak-object-will-be-added-to-autorelease-pool" target="_blank" rel="noopener">Why __weak object will be added to autorelease pool?</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/01/21/带着问题看源码----子线程AutoRelease对象何时释放/" itemprop="url">
                  带着问题看源码----子线程AutoRelease对象何时释放
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-01-21T20:01:01+08:00" content="2018-01-21">
              2018-01-21
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>首先是一个常规问题，autorelease对象何时释放？答：在AutoreleasePoolPage pop的时候释放，在主线程的runloop中，有两个oberserver负责创建和清空autoreleasepool，详情可以看YY的<a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">深入理解runloop</a>。那么子线程呢？子线程的runloop都需要手动开启，那么子线程中使用autorelease对象会内存泄漏吗，如果不会又是什么时候释放呢。</p>
<h2 id="Runloop源码"><a href="#Runloop源码" class="headerlink" title="Runloop源码"></a>Runloop源码</h2><p>带着这个问题，我们看一看runloop的源码中给出的答案。</p>
<h3 id="autoreleasepool创建"><a href="#autoreleasepool创建" class="headerlink" title="autoreleasepool创建"></a>autoreleasepool创建</h3><p>在MRC下，使用__autoreleasing修饰符等同于MRC下调用autorelease方法，所以在NSObject源码中找到-(id)autorelese方法开始看。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-(id) autorelease</span><br><span class="line">&#123;</span><br><span class="line">    return _objc_rootAutorelease(self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这个方法里只是简单的调了一下<code>_objc_rootAutorelease()</code>，继续跟进。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line">_objc_rootAutorelease(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    assert(obj);</span><br><span class="line">    return obj-&gt;rootAutorelease();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">// Base autorelease implementation, ignoring overrides.</span><br><span class="line">inline id </span><br><span class="line">objc_object::rootAutorelease()</span><br><span class="line">&#123;</span><br><span class="line">    if (isTaggedPointer()) return (id)this;</span><br><span class="line">    if (prepareOptimizedReturn(ReturnAtPlus1)) return (id)this;</span><br><span class="line"></span><br><span class="line">    return rootAutorelease2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">__attribute__((noinline,used))</span><br><span class="line">id </span><br><span class="line">objc_object::rootAutorelease2()</span><br><span class="line">&#123;</span><br><span class="line">    assert(!isTaggedPointer());</span><br><span class="line">    return AutoreleasePoolPage::autorelease((id)this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检查是否AutoreleasePoolPage::autorelease是标签指针和是否要做不加入autoreleasepool的优化，然后<code>rootAutorelease2()</code>。最后走入了<code>AutoreleasePoolPage::autorelease()</code>。<br>接下来看看<code>AutoreleasePoolPage</code>这个类，有关这个类的说明，可以看看sunny的<a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="noopener">黑幕背后的Autorelease</a>。现在来看看AutoreleasePoolPage中的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">public:</span><br><span class="line">    static inline id autorelease(id obj)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(obj);</span><br><span class="line">        assert(!obj-&gt;isTaggedPointer());</span><br><span class="line">        id *dest __unused = autoreleaseFast(obj);</span><br><span class="line">        assert(!dest  ||  dest == EMPTY_POOL_PLACEHOLDER  ||  *dest == obj);</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    static inline id *autoreleaseFast(id obj)</span><br><span class="line">    &#123;</span><br><span class="line">        AutoreleasePoolPage *page = hotPage();</span><br><span class="line">        if (page &amp;&amp; !page-&gt;full()) &#123;</span><br><span class="line">            return page-&gt;add(obj);</span><br><span class="line">        &#125; else if (page) &#123;</span><br><span class="line">            return autoreleaseFullPage(obj, page);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return autoreleaseNoPage(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">        static __attribute__((noinline))</span><br><span class="line">    id *autoreleaseNoPage(id obj)</span><br><span class="line">    &#123;</span><br><span class="line">        // &quot;No page&quot; could mean no pool has been pushed</span><br><span class="line">        // or an empty placeholder pool has been pushed and has no contents yet</span><br><span class="line">        assert(!hotPage());</span><br><span class="line"></span><br><span class="line">        bool pushExtraBoundary = false;</span><br><span class="line">        if (haveEmptyPoolPlaceholder()) &#123;</span><br><span class="line">            // We are pushing a second pool over the empty placeholder pool</span><br><span class="line">            // or pushing the first object into the empty placeholder pool.</span><br><span class="line">            // Before doing that, push a pool boundary on behalf of the pool </span><br><span class="line">            // that is currently represented by the empty placeholder.</span><br><span class="line">            pushExtraBoundary = true;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (obj != POOL_BOUNDARY  &amp;&amp;  DebugMissingPools) &#123;</span><br><span class="line">            // We are pushing an object with no pool in place, </span><br><span class="line">            // and no-pool debugging was requested by environment.</span><br><span class="line">            _objc_inform(&quot;MISSING POOLS: (%p) Object %p of class %s &quot;</span><br><span class="line">                         &quot;autoreleased with no pool in place - &quot;</span><br><span class="line">                         &quot;just leaking - break on &quot;</span><br><span class="line">                         &quot;objc_autoreleaseNoPool() to debug&quot;, </span><br><span class="line">                         pthread_self(), (void*)obj, object_getClassName(obj));</span><br><span class="line">            objc_autoreleaseNoPool(obj);</span><br><span class="line">            return nil;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (obj == POOL_BOUNDARY  &amp;&amp;  !DebugPoolAllocation) &#123;</span><br><span class="line">            // We are pushing a pool with no pool in place,</span><br><span class="line">            // and alloc-per-pool debugging was not requested.</span><br><span class="line">            // Install and return the empty pool placeholder.</span><br><span class="line">            return setEmptyPoolPlaceholder();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // We are pushing an object or a non-placeholder&apos;d pool.</span><br><span class="line"></span><br><span class="line">        // Install the first page.</span><br><span class="line">        AutoreleasePoolPage *page = new AutoreleasePoolPage(nil);</span><br><span class="line">        setHotPage(page);</span><br><span class="line">        </span><br><span class="line">        // Push a boundary on behalf of the previously-placeholder&apos;d pool.</span><br><span class="line">        if (pushExtraBoundary) &#123;</span><br><span class="line">            page-&gt;add(POOL_BOUNDARY);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // Push the requested object or pool.</span><br><span class="line">        return page-&gt;add(obj);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里我们找到了我们想看的代码，如果当前线程没有AutorelesepoolPage的话，代码执行顺序为autorelease -&gt; autoreleaseFast -&gt; autoreleaseNoPage。<br>在autoreleaseNoPage方法中，会创建一个hotPage，然后调用page-&gt;add(obj)。也就是说即使这个线程没有AutorelesepoolPage，使用了autorelease对象时也会new一个AutoreleasepoolPage出来管理autorelese对象，不用担心内存泄漏。</p>
<h3 id="何时释放"><a href="#何时释放" class="headerlink" title="何时释放"></a>何时释放</h3><p>明确了何时创建autoreleasepool以后就自然而然的有下一个问题，这个autoreleasepool何时清空？<br>对于这个问题，这里使用<code>watchpoint set variable</code>命令来观察。<br>首先是一个最简单的场景，创建一个子线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__weak id obj;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">[NSThread detachNewThreadSelector:@selector(createAndConfigObserverInSecondaryThread) toTarget:self withObject:nil];</span><br></pre></td></tr></table></figure>
<p>使用一个weak指针观察子线程中的autorelease对象，子线程中执行的任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)createAndConfigObserverInSecondaryThread&#123;</span><br><span class="line">    __autoreleasing id test = [NSObject new];</span><br><span class="line">    NSLog(@&quot;obj = %@&quot;, test);</span><br><span class="line">    obj = test;</span><br><span class="line">    [[NSThread currentThread] setName:@&quot;test runloop thread&quot;];</span><br><span class="line">    NSLog(@&quot;thread ending&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在obj = test处设置断点使用<code>watchpoint set variable obj</code>命令观察obj，可以看到obj在释放时的方法调用栈是这样的。<br><img src="/pics/threadwithoutrunloop.png" alt="threadwithoutrunloop"><br>通过这个调用栈可以看到释放的时机在_pthread_exit。然后执行到AutorelepoolPage的tls_dealloc方法。这个方法如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static void tls_dealloc(void *p)</span><br><span class="line">&#123;</span><br><span class="line">    if (p == (void*)EMPTY_POOL_PLACEHOLDER) &#123;</span><br><span class="line">        // No objects or pool pages to clean up here.</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // reinstate TLS value while we work</span><br><span class="line">    setHotPage((AutoreleasePoolPage *)p);</span><br><span class="line"></span><br><span class="line">    if (AutoreleasePoolPage *page = coldPage()) &#123;</span><br><span class="line">        if (!page-&gt;empty()) pop(page-&gt;begin());  // pop all of the pools</span><br><span class="line">        if (DebugMissingPools || DebugPoolAllocation) &#123;</span><br><span class="line">            // pop() killed the pages already</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            page-&gt;kill();  // free all of the pages</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // clear TLS value so TLS destruction doesn&apos;t loop</span><br><span class="line">    setHotPage(nil);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 在这找到了<code>if (!page-&gt;empty()) pop(page-&gt;begin());</code>这句关键代码。再往上看一点，在_pthread_exit时会执行下面这个函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">_pthread_tsd_cleanup(pthread_t self)</span><br><span class="line">&#123;</span><br><span class="line">#if !VARIANT_DYLD</span><br><span class="line">	int j;</span><br><span class="line"></span><br><span class="line">	// clean up dynamic keys first</span><br><span class="line">	for (j = 0; j &lt; PTHREAD_DESTRUCTOR_ITERATIONS; j++) &#123;</span><br><span class="line">		pthread_key_t k;</span><br><span class="line">		for (k = __pthread_tsd_start; k &lt;= self-&gt;max_tsd_key; k++) &#123;</span><br><span class="line">			_pthread_tsd_cleanup_key(self, k);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	self-&gt;max_tsd_key = 0;</span><br><span class="line"></span><br><span class="line">	// clean up static keys</span><br><span class="line">	for (j = 0; j &lt; PTHREAD_DESTRUCTOR_ITERATIONS; j++) &#123;</span><br><span class="line">		pthread_key_t k;</span><br><span class="line">		for (k = __pthread_tsd_first; k &lt;= __pthread_tsd_max; k++) &#123;</span><br><span class="line">			_pthread_tsd_cleanup_key(self, k);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">#endif // !VARIANT_DYLD</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说thread在退出时会释放自身资源，这个操作就包含了销毁autoreleasepool，在tls_delloc中，执行了pop操作。<br>这个实验本该到此就结束了，对于文章开始的问题在这里也已经有了答案，线程在销毁时会清空autoreleasepool。但是上述这个例子中的线程并没有加入runloop，只是一个一次性的线程。现在给这个线程加入runloop来看看效果会是怎么样的。</p>
<h3 id="runloop-source-amp-autoreleasepool"><a href="#runloop-source-amp-autoreleasepool" class="headerlink" title="runloop source &amp; autoreleasepool"></a>runloop source &amp; autoreleasepool</h3><p>对于runloop，我们知道runloop一定要有source才能保证run起来以后不立即结束，而source有三种，custom source，port source，timer。<br>先加一个timer试试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (void)createAndConfigObserverInSecondaryThread&#123;</span><br><span class="line">    [[NSThread currentThread] setName:@&quot;test runloop thread&quot;];</span><br><span class="line">    NSRunLoop *loop = [NSRunLoop currentRunLoop];</span><br><span class="line">    CFRunLoopObserverRef observer;</span><br><span class="line">    observer = CFRunLoopObserverCreate(CFAllocatorGetDefault(),</span><br><span class="line">                                       kCFRunLoopAllActivities,</span><br><span class="line">                                       true,      // repeat</span><br><span class="line">                                       0xFFFFFF,  // after CATransaction(2000000)</span><br><span class="line">                                       YYRunLoopObserverCallBack, NULL);</span><br><span class="line">    CFRunLoopRef cfrunloop = [loop getCFRunLoop];</span><br><span class="line">    if (observer) &#123;</span><br><span class="line">        </span><br><span class="line">        CFRunLoopAddObserver(cfrunloop, observer, kCFRunLoopCommonModes);</span><br><span class="line">        CFRelease(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    [NSTimer scheduledTimerWithTimeInterval:5 target:self selector:@selector(testAction) userInfo:nil repeats:YES];</span><br><span class="line">    [loop run];</span><br><span class="line">    NSLog(@&quot;thread ending&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)testAction&#123;</span><br><span class="line">    __autoreleasing id test = [NSObject new];</span><br><span class="line">    obj = test;</span><br><span class="line">    NSLog(@&quot;obj = %@&quot;, obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的oberserver没有什么，就是从YYKit里复制出来的一段observer代码，用于监控runloop的状态。感兴趣的可以看看。<br>在<code>testAction()</code>中加上watchpoint断点，观察obj的释放时机。<br><img src="/pics/timersource.png" alt><br>可以看到释放的时机在CFRunloopRunSpecific中，也就是runloop切换状态的时候，继续往上看发现<code>__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__()</code>这个回调。这个函数中的实现如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static void __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(CFRunLoopTimerCallBack func, CFRunLoopTimerRef timer, void *info) &#123;</span><br><span class="line">    if (func) &#123;</span><br><span class="line">        func(timer, info);</span><br><span class="line">    &#125;</span><br><span class="line">    asm __volatile__(&quot;&quot;); // thwart tail-call optimization</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个名为<code>func</code>的callback是timer的一个属性，根据这个调用栈看到，释放autoreleasepool的操作应该是在这个callback中。这里猜测一下timer，应该是在自己的callback函数里插入了释放autorelesepool的代码。<br>然后用自己实现的source试一试，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">- (void)createAndConfigObserverInSecondaryThread&#123;</span><br><span class="line">    __autoreleasing id test = [NSObject new];</span><br><span class="line">    NSLog(@&quot;obj = %@&quot;, test);</span><br><span class="line">    obj = test;</span><br><span class="line">    [[NSThread currentThread] setName:@&quot;test runloop thread&quot;];</span><br><span class="line">    NSRunLoop *loop = [NSRunLoop currentRunLoop];</span><br><span class="line">    CFRunLoopObserverRef observer;</span><br><span class="line">    observer = CFRunLoopObserverCreate(CFAllocatorGetDefault(),</span><br><span class="line">                                       kCFRunLoopAllActivities,</span><br><span class="line">                                       true,      // repeat</span><br><span class="line">                                       0xFFFFFF,  // after CATransaction(2000000)</span><br><span class="line">                                       YYRunLoopObserverCallBack, NULL);</span><br><span class="line">    CFRunLoopRef cfrunloop = [loop getCFRunLoop];</span><br><span class="line">    if (observer) &#123;</span><br><span class="line">        </span><br><span class="line">        CFRunLoopAddObserver(cfrunloop, observer, kCFRunLoopCommonModes);</span><br><span class="line">        CFRelease(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    CFRunLoopSourceRef source;</span><br><span class="line">    CFRunLoopSourceContext sourceContext = &#123;0, (__bridge void *)(self), NULL, NULL, NULL, NULL, NULL, NULL, NULL, &amp;runLoopSourcePerformRoutine&#125;;</span><br><span class="line">    source = CFRunLoopSourceCreate(NULL, 0, &amp;sourceContext);</span><br><span class="line">    CFRunLoopAddSource(cfrunloop, source, kCFRunLoopDefaultMode);</span><br><span class="line">    runLoopSource = source;</span><br><span class="line">    runLoop = cfrunloop;</span><br><span class="line">    [loop run];</span><br><span class="line">    NSLog(@&quot;thread ending&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)wakeupSource&#123;</span><br><span class="line">    //通知InputSource</span><br><span class="line">    CFRunLoopSourceSignal(runLoopSource);</span><br><span class="line">    //唤醒runLoop</span><br><span class="line">    CFRunLoopWakeUp(runLoop);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">void runLoopSourcePerformRoutine (void *info)</span><br><span class="line">&#123;</span><br><span class="line">	  __autoreleasing id test = [NSObject new];</span><br><span class="line">    obj = test;</span><br><span class="line">    // 如果不对obj赋值，obj会一直持有createAndConfigObserverInSecondaryThread函数入口的那个object，那个object不受这里面的autoreleasepool影响。</span><br><span class="line">    NSLog(@&quot;obj is %@&quot; , obj);</span><br><span class="line">    NSLog(@&quot;回调方法%@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里<code>wakeupSource()</code>是一个按钮的点击事件，用于唤醒runloop。runloop唤醒之后将执行<code>runLoopSourcePerformRoutine</code>函数，在<code>runLoopSourcePerformRoutine()</code>中观察obj的释放时机，发现是在[NSRunloop run:beforeDate:]中，查看GNU的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL) runMode: (NSString*)mode beforeDate: (NSDate*)date</span><br><span class="line">&#123;</span><br><span class="line">  NSAutoreleasePool	*arp = [NSAutoreleasePool new];</span><br><span class="line">  NSString              *savedMode = _currentMode;</span><br><span class="line">  GSRunLoopCtxt		*context;</span><br><span class="line">  NSDate		*d;</span><br><span class="line"></span><br><span class="line">  NSAssert(mode != nil, NSInvalidArgumentException);</span><br><span class="line"></span><br><span class="line">  /* Process any pending notifications.</span><br><span class="line">   */</span><br><span class="line">  GSPrivateNotifyASAP(mode);</span><br><span class="line"></span><br><span class="line">  /* And process any performers scheduled in the loop (eg something from</span><br><span class="line">   * another thread.</span><br><span class="line">   */</span><br><span class="line">  _currentMode = mode;</span><br><span class="line">  context = NSMapGet(_contextMap, mode);</span><br><span class="line">  [self _checkPerformers: context];</span><br><span class="line">  _currentMode = savedMode;</span><br><span class="line"></span><br><span class="line">  /* Find out how long we can wait before first limit date.</span><br><span class="line">   * If there are no input sources or timers, return immediately.</span><br><span class="line">   */</span><br><span class="line">  d = [self limitDateForMode: mode];</span><br><span class="line">  if (nil == d)</span><br><span class="line">    &#123;</span><br><span class="line">      [arp drain];</span><br><span class="line">      return NO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  /* Use the earlier of the two dates we have (nil date is like distant past).</span><br><span class="line">   */</span><br><span class="line">  if (nil == date)</span><br><span class="line">    &#123;</span><br><span class="line">      [self acceptInputForMode: mode beforeDate: nil];</span><br><span class="line">    &#125;</span><br><span class="line">  else</span><br><span class="line">    &#123;</span><br><span class="line">      /* Retain the date in case the firing of a timer (or some other event)</span><br><span class="line">       * releases it.</span><br><span class="line">       */</span><br><span class="line">      d = [[d earlierDate: date] copy];</span><br><span class="line">      [self acceptInputForMode: mode beforeDate: d];</span><br><span class="line">      RELEASE(d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  [arp drain];</span><br><span class="line">  return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在GNU的实现中，targer执行相应的action操作是在<code>[self acceptInputForMode: mode beforeDate: d];</code>中，可以看到在<code>runMode: (NSString*)mode beforeDate: (NSDate*)date</code>方法中，其实是包裹了一个autoreleasepool的，也就是<code>arp</code>，如果在深入一些函数里面，发现其实很多地方都有autoreleasepool的函数，所以即使是我们自定义的source，执行函数中没有释放autoreleasepool的操作也不用担心，系统在各个关键入口都给我们加了这些操作。<br>文章到此就告一段落了，还有一种port source，也就是source1，这种source我没有去看，好奇的同学可以去看一看如果有什么不对我们一起讨论。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1.子线程在使用autorelease对象时，如果没有autoreleasepool会在autoreleaseNoPage中懒加载一个出来。<br>2.在runloop的run:beforeDate，以及一些source的callback中，有autoreleasepool的push和pop操作，总结就是系统在很多地方都差不多autorelease的管理操作。<br>3.就算插入没有pop也没关系，在线程exit的时候会释放资源，执行AutoreleasePoolPage::tls_dealloc，在这里面会清空autoreleasepool。</p>
<p>##参考<br><a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">深入理解runloop</a><br><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="noopener">黑幕背后的Autorelease</a><br><a href="https://stackoverflow.com/questions/24952549/does-nsthread-create-autoreleasepool-automatically-now" target="_blank" rel="noopener">stackover flow</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/01/17/带着问题读源码----KVO/" itemprop="url">
                  带着问题读源码----KVO
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-01-17T22:15:50+08:00" content="2018-01-17">
              2018-01-17
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>面试的时候被多次问到KVO，被问起KVO的实现原理只是简单的知道会生成一个中间派生类，改类是原类的子类。然后被追问如果自己实现KVO，要怎么实现这个派生类。被观察的对象在addObserverForKey之后改对象的isa就被指向了派生类，那么[obj description]打印出来的为什么还是原来的类名。<br>带着这些问题，开始看KVO的源码。</p>
<h2 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h2><p>KVO的源码并不是开源的，所以并不知道苹果是如何实现的，幸好还有一套GNU的实现，可以给我们提供一下思路。GNU的下载地址在<a href="http://gnustep.org" target="_blank" rel="noopener">这里</a>。<br>对于派生类，下面代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj = [[MyObject alloc] init];</span><br><span class="line">[obj addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew context:nil];</span><br></pre></td></tr></table></figure></p>
<p>当调用到最后一个方法时，runtime已经生成了一个子类，obj的isa指向新的子类，MyObject是新子类的父类。他们之间的关系如下图。</p>
<p><img src="https://raw.githubusercontent.com/war3tiger/war3tiger.github.io/master/resources/kvo/kvo.png" alt="派生类关系图"></p>
<p>现在来看看GNU中对这一块的实现。</p>
<h2 id="GNU实现"><a href="#GNU实现" class="headerlink" title="GNU实现"></a>GNU实现</h2><p>在GNU的实现中，有两个关键的类:<code>GSKVOReplacement</code>、<code>GSKVOBase</code>。<br>从<code>NSKeyValueObserving.m</code>中的<code>- (void) addObserver: (NSObject*)anObserver forKeyPath: (NSString*)aPath options: (NSKeyValueObservingOptions)options context: (void*)aContext</code><br>方法开始看。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">GSKVOInfo             *info;</span><br><span class="line">GSKVOReplacement      *r;</span><br><span class="line">NSKeyValueObservationForwarder *forwarder;</span><br><span class="line">NSRange               dot;</span><br><span class="line"></span><br><span class="line">setup();</span><br><span class="line">[kvoLock lock];</span><br><span class="line"></span><br><span class="line">// Use the original class</span><br><span class="line">r = replacementForClass([self class]);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Get the existing observation information, creating it (and changing</span><br><span class="line"> * the receiver to start key-value-observing by switching its class)</span><br><span class="line"> * if necessary.</span><br><span class="line"> */</span><br><span class="line">info = (GSKVOInfo*)[self observationInfo];</span><br><span class="line">if (info == nil)</span><br><span class="line">  &#123;</span><br><span class="line">    info = [[GSKVOInfo alloc] initWithInstance: self];</span><br><span class="line">    [self setObservationInfo: info];</span><br><span class="line">    object_setClass(self, [r replacement]);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>在这里，找到里面两行关键函数：<br><code>r = replacementForClass([self class]);</code> 和 <code>object_setClass(self, [r replacement]);</code>。通过这两个函数obj就可以将自己的isa设置为runtime生成的派生类。而这个派生类体现在代码中就是<code>[r replacement]</code>。查看<code>GSKVOReplacement</code>的定义发现replacement方法返回的就是<code>GSKVOReplacement</code>中的一个名为<code>replacement</code>的Class对象。<br>接下来看一看这个名为<code>r</code>的<code>GSKVOReplacement</code>对象是如何生成的。看一看<code>static GSKVOReplacement * replacementForClass(Class c)</code>函数是如何实现的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GSKVOReplacement *r;</span><br><span class="line"></span><br><span class="line">setup();</span><br><span class="line">[kvoLock lock];</span><br><span class="line">r = (GSKVOReplacement*)NSMapGet(classTable, (void*)c);</span><br><span class="line">if (r == nil)</span><br><span class="line">  &#123;</span><br><span class="line">    r = [[GSKVOReplacement alloc] initWithClass: c];</span><br><span class="line">    NSMapInsert(classTable, (void*)c, (void*)r);</span><br><span class="line">  &#125;</span><br><span class="line">[kvoLock unlock];</span><br><span class="line">return r;</span><br></pre></td></tr></table></figure>
<p>在这个函数中，首先执行了静态内联函数<code>setup()</code>。在<code>setup()</code>函数中，初始化了classTable等相关的表。并且初始化了静态变量<code>baseClass</code>，这个<code>baseClass</code>是一个<code>GSKVOBase</code>类对象。<br>在<code>replacementForClass()</code>函数中通过传入的原Class比如MyObject，在classTable中找寻派生类比如KVO_MyObject。如果没找到，通过<code>GSKVOReplacement</code>的<code>initWithClass:</code>方法新建一个并且插入到classTable中。<br>那么看一看<code>initWithClass</code>又是如何实现的呢。<code>initWithClass</code>实现代码比较长，这里就贴几句关键代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">original = aClass;</span><br><span class="line"></span><br><span class="line"> /*</span><br><span class="line">  * Create subclass of the original, and override some methods</span><br><span class="line">  * with implementations from our abstract base class.</span><br><span class="line">  */</span><br><span class="line"> superName = NSStringFromClass(original);</span><br><span class="line"> name = [@&quot;GSKVO&quot; stringByAppendingString: superName];</span><br><span class="line"> template = GSObjCMakeClass(name, superName, nil);</span><br><span class="line"> GSObjCAddClasses([NSArray arrayWithObject: template]);</span><br><span class="line"> replacement = NSClassFromString(name);</span><br><span class="line"> GSObjCAddClassBehavior(replacement, baseClass);</span><br><span class="line"></span><br><span class="line"> /* Create the set of setter methods overridden.</span><br><span class="line">  */</span><br><span class="line"> keys = [NSMutableSet new];</span><br><span class="line"></span><br><span class="line"> return self;</span><br></pre></td></tr></table></figure></p>
<p>根据代码可以看到大致的流程为：<br>1.通过原类拼接派生类的子类名<br>2.通过<code>GSObjCAddClasses()</code>创建新类，在该函数中，通过superName反射创建superClass，也就是MyObject的class。通过name和objc_allocateClassPair函数创建一个新的Class，也就是派生类。将生成的class对象包装在NSValue中返回给template。<br>3.通过GSObjCAddClasses将template里的派生类对象注册好。<br>4.注册好了以后就可以通过name反射得到派生类的class对象relpacement。<br>5.通过<code>GSObjCAddClassBehavior(Class receiver, Class behavior)</code>为replacement添加相应的方法。这个函数传入的两个参数分别是派生类和baseClass，也就是GSKVOBase。<br><code>GSObjCAddClassBehavior(Class receiver, Class behavior)</code>这个函数非常关键，简单看一下其中的关键代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"> unsigned int	count;</span><br><span class="line"> Method	*methods;</span><br><span class="line"> Class behavior_super_class = class_getSuperclass(behavior);</span><br><span class="line"> </span><br><span class="line"> 	...</span><br><span class="line">/* 一些不是很关键的代码 */</span><br><span class="line"></span><br><span class="line"> /* Add instance methods */</span><br><span class="line"> methods = class_copyMethodList(behavior, &amp;count);</span><br><span class="line"> BDBGPrintf(&quot;  instance methods from %s %u\n&quot;, class_getName(behavior), count);</span><br><span class="line"> if (methods == NULL)</span><br><span class="line">   &#123;</span><br><span class="line">     BDBGPrintf(&quot;    none.\n&quot;);</span><br><span class="line">   &#125;</span><br><span class="line"> else</span><br><span class="line">   &#123;</span><br><span class="line">     GSObjCAddMethods (receiver, methods, NO);</span><br><span class="line">     free(methods);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> /* Add class methods */</span><br><span class="line"> methods = class_copyMethodList(object_getClass(behavior), &amp;count);</span><br><span class="line"> BDBGPrintf(&quot;  class methods from %s %u\n&quot;, class_getName(behavior), count);</span><br><span class="line"> if (methods == NULL)</span><br><span class="line">   &#123;</span><br><span class="line">     BDBGPrintf(&quot;    none.\n&quot;);</span><br><span class="line">   &#125;</span><br><span class="line"> else</span><br><span class="line">   &#123;</span><br><span class="line">     GSObjCAddMethods (object_getClass(receiver), methods, NO);</span><br><span class="line">     free(methods);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> /* Add behavior&apos;s superclass, if not already there. */</span><br><span class="line"> if (!GSObjCIsKindOf(receiver, behavior_super_class))</span><br><span class="line">   &#123;</span><br><span class="line">     GSObjCAddClassBehavior (receiver, behavior_super_class);</span><br><span class="line">   &#125;</span><br><span class="line"> GSFlushMethodCacheForClass (receiver);</span><br></pre></td></tr></table></figure>
<p>跳过一些不那么关键的代码后其实非常简单，就是把behavior中的方法列表copy一份到receiver中。其中behavior是GSKVOBase，reveiver是派生类，也就是我们obj的isa最后指向的对象。<br>那么看一看GSKVOBase是如何实现的吧。<br>GSKVOBase有两个关键方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (Class) class</span><br><span class="line">&#123;</span><br><span class="line">  return class_getSuperclass(object_getClass(self));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void) setValue: (id)anObject forKey: (NSString*)aKey</span><br><span class="line">&#123;</span><br><span class="line">  Class		c = [self class];</span><br><span class="line">  void		(*imp)(id,SEL,id,id);</span><br><span class="line"></span><br><span class="line">  imp = (void (*)(id,SEL,id,id))[c instanceMethodForSelector: _cmd];</span><br><span class="line"></span><br><span class="line">  if ([[self class] automaticallyNotifiesObserversForKey: aKey])</span><br><span class="line">    &#123;</span><br><span class="line">      [self willChangeValueForKey: aKey];</span><br><span class="line">      imp(self,_cmd,anObject,aKey);</span><br><span class="line">      [self didChangeValueForKey: aKey];</span><br><span class="line">    &#125;</span><br><span class="line">  else</span><br><span class="line">    &#123;</span><br><span class="line">      imp(self,_cmd,anObject,aKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先重写了自己的class方法，返回的是自己的superClass，这也就是为什么KVO了obj之后[obj description]打印出来的还是MyObject信息。在<code>setValue:forKey:</code>方法中，通过<code>automaticallyNotifiesObserversForKey:</code>判断该key是否被kvo了，如果被kvo了就插入willChangeValueForKey和didChangeValueForKey两个方法。如果没有，执行原有的set方法即可。也就是说replacement中并没有重写所有的任何的set方法，而是通过这种很巧妙的操作记录一下被kvo的key，然后在该key执行set方法时，插入kvo需要的语句，这一切，都是通过runtime来进行的。<br>看到这里，文章开头的两个问题其实已经有答案了，GNU的这个实现其实就可以作为自己实现KVO的思路，而苹果在官方文档中关于kvo有这么一句话</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">You should never rely on the isa pointer to determine class membership. Instead, you should use the class method to determine the class of an object instance.</span><br></pre></td></tr></table></figure>
<p>这么说的原因，对照GNU这里的代码看，其实就是因为重写了派生类的Class方法，所以不能依赖派生类的Class来判断类的关系。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于KVO的实现，GNU给出的这套实现中还有很多细节，但是基本的思想就是有一个模版类<code>GSKVOBase</code>，这个类中定义了一些基本行为，例如Class方法，setValue:forKey:方法，所有的派生类（replacement）的方法列表都来自于该模版类，这样就派生类就可以做成一个轻量级的对象，不用重写特定的set方法，在调用被KVO的对象其它方法时，也能保证调用的是原Class方法列表中的IMP，不至于出错。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://war3tiger.github.io/jekyll/update/2017/07/18/KVO.html" target="_blank" rel="noopener">KVO原理浅析</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/09/29/KVC原理小记/" itemprop="url">
                  KVC原理小记录
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-09-29T15:16:33+08:00" content="2017-09-29">
              2017-09-29
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>无意看到KVC原理的文章，发现很多中文文章说的都不全面，翻了一下官网文档，记录一下</p>
<h2 id="basic-getters"><a href="#basic-getters" class="headerlink" title="basic getters"></a>basic getters</h2><p>基础的valueForKey:</p>
<p>1.搜寻实例对象存取方法，搜寻的方法名顺序为：<code>get&lt;Key&gt;</code>，<code>&lt;key&gt;</code>,<code>is&lt;Key&gt;</code>或者<code>_&lt;key&gt;</code>，如果搜寻到了类似的方法，将结果带入第5步。否则进行下一步<br>2.如果没有找到简单的访问器方法，开始寻找符合<code>countOf&lt;Key&gt;</code>,<code>objectIn&lt;Key&gt;AtIndex：</code>(与NSArray类的初始方法相对应地方法，参数也与NSArray的对应方法一样)和<code>&lt;key&gt;AtIndexs:</code>(与NSArray的<code>objectsAtIndexes:</code>对应)这种命名规则的方法。如果第一个方法(<code>countOf&lt;Key&gt;</code>)和剩下两个方法中的至少一个被发现了，创建一个能够响应所有NSArray方法的集合代理对象返回（断点调试看到的是NSKeyValueArray对象）。如果没有，进入第三步<br>上面创建的代理对象随后将它收到的所有NSArray相关的消息（调用）转换成创建它的那个符合kvc规则的对象中<code>countOf&lt;Key&gt;</code>,<code>objectIn&lt;Key&gt;AtIndex：</code>和<code>&lt;key&gt;AtIndexs:</code>的消息结合。如果原始的对象还实现了一个可选方法名字符合<code>get&lt;Key&gt;:range:</code>的范式，该代理对象在适当的时候也会使用改方法。实际上，这个代理对象和这个符合kvc规则的对象共同工作，允许下面的属性像一个NSArray一个呈现，即使那个属性并不是array。<br>3.如果简单的访问器方法和上述数组访问方法都没有，则开始搜寻三个名为<code>countOf&lt;Key&gt;</code>,<code>enumeratorOf&lt;Key&gt;</code>和<code>memberOf&lt;Key:&gt;</code>的方法（与NSSet中的原始方法相对应）<br>如果三个方法都实现了，创造一个能够响应所有NSSet方法的集合代理对象返回（这里没做实验）。否则进入第4步<br>这个代理对象随后将收到的所有NSSet消息（调用）转换成创造它的那个对象中<code>countOf&lt;Key&gt;</code>,<code>enumeratorOf&lt;Key&gt;</code>和<code>memberOf&lt;Key&gt;:</code>消息的组合。实际上，这个代理对象和这个符合kvc规则的对象共同工作，允许下面的属性像一个NSSet一个呈现，即使那个属性并不是set<br>4.如果上述的简单访问器方法和集合访问方法都没有找到，并且这个消息接收者的<code>accessInstanceVariablesDirectly</code>返回YES，那么按照<code>_&lt;key&gt;</code>,<code>_is&lt;Key&gt;</code>,<code>&lt;key&gt;</code>,或者<code>is&lt;Key&gt;</code>的顺序搜寻符合的实例变量。如果找到了，直接获取改实例变量进入第5步，如果没有，进入第6步。<br>5.如果返回的值是一个对象指针，直接返回<br>如果返回的是一个可以被包装成NSNumber的基础类型，包装成NSNumber返回<br>如果返回的是一个不能被包装成NSNumber的基础类型，转换成一个NSValue对象返回<br>6.如果上面所有的都失败了，调用<code>valueForUndefinedKey:</code>方法，这个方法默认会生成一个异常(crash在这方法里)，不过NSObject的子类可以继承根据key做一些特定处理。</p>
<h2 id="basic-setter"><a href="#basic-setter" class="headerlink" title="basic setter"></a>basic setter</h2><p>setValue:forKey:</p>
<p>1.首先按顺序查找名为<code>set&lt;Key&gt;:</code>或者<code>_set&lt;Key&gt;:</code>方法，如果存在，将输入的值(或者解除封装，例如<code>setvalue</code>中传的一个NSNumber，<code>set&lt;Key&gt;:</code>中接收的是一个NSInteger)传入方法中调用。<br>2.如果简单的存取方法没找到，并且类的a<code>ccessInstanceVariablesDirectly</code>返回YES，按照<code>_&lt;key&gt;</code>,<code>_is&lt;Key&gt;</code>,<code>&lt;key&gt;</code>,或者<code>is&lt;Key&gt;</code>的名字顺序查找实例变量。如果找到了，直接设置变量值为输入值并且结束。<br>3.如果存取方法和实例变量都没找到，调用<code>setValue:forUndefinedKey:</code>方法，这个方法默认会生成一个异常，不果继承NSObject的子类可以根据key提供一些特定的处理</p>
<p>待续，后面还有为集合类set方法。</p>
<p>#参考<br><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/SearchImplementation.html#//apple_ref/doc/uid/20000955-CJBBBFFA" target="_blank" rel="noopener">Key-Value Coding Programming Guide</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/04/Objective-c 动态运行时语言是什么意思/" itemprop="url">
                  Objective-c 动态运行时语言是什么意思
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-07-04T18:04:35+08:00" content="2017-07-04">
              2017-07-04
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>看到一个题目是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们说的objective-c是动态运行时语言是什么意思（when we call objective c is runtime language what does it mean）</span><br></pre></td></tr></table></figure></p>
<p>记录一下，其实很简单，但是之前没有细致的去看官方文档说明，分两个方面：动态类型(dynamic type)和动态绑定(dynamic binding)</p>
<h2 id="动态类型"><a href="#动态类型" class="headerlink" title="动态类型"></a>动态类型</h2><p>动态类型指的是对象指针类型的动态性,意思就是对象的类型确定将会推迟到运行时。由赋值给它的对象类型决定对象指针的类型。</p>
<p>另外类型确定推迟到运行时之后，可以通过NSObject的isKindOfClass方法动态判断对象最后的类型（动态类型识别）。可以把id修饰的对象理解为动态类型对象，其他在编译器指明类型的为静态类型对象，通常如果不需要涉及到多态的话还是要尽量使用静态类型。因为出错了的话编译器可以提前查出，可读性也好。<br>举例说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString* testObject = [[NSData alloc] init];</span><br></pre></td></tr></table></figure></p>
<p>这句话声明了一个NSString指针，但是赋值了一个NSData对象。所以在编译期下面两句话：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[testObject stringByAppendingString:@&quot;string&quot;];  //1</span><br><span class="line">[testObject base64EncodedDataWithOptions:NSDataBase64Encoding64CharacterLineLength]; //2</span><br></pre></td></tr></table></figure></p>
<p>第一句话在编译期可以通过，因为编译期testObject的类型是NSString,所以第二句话会报错，因为那是NSData的方法导致程序跑不起来。<br>然后如果注释掉第二句话将程序run起来，程序将会在第一句话处crash，因为赋值给testObject的对象是一个NSData对象，而NSData没有stringByAppendingString方法，导致crash。</p>
<p>如果将testObject声明为id类型则两句话都可以编译通过。但是运行时一样会crash在stringByAppendingString，原因同上。</p>
<p>摘抄一段官方文档的说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">A variable is dynamically typed when the type of the object it points to is not </span><br><span class="line">checked at compile time. Objective-C uses the id data type to represent a variable </span><br><span class="line">that is an object without specifying what sort of object it is. This is referred </span><br><span class="line">to as dynamic typing.</span><br><span class="line"></span><br><span class="line">Dynamic typing contrasts with static typing, in which the system explicitly </span><br><span class="line">identifies the class to which an object belongs at compile time. Static type </span><br><span class="line">checking at compile time may ensure stricter data integrity, but in exchange for </span><br><span class="line">that integrity, dynamic typing gives your program much greater flexibility. And </span><br><span class="line">through object introspection (for example, asking a dynamically typed, anonymous </span><br><span class="line">object what its class is), you can still verify the type of an object at runtime</span><br><span class="line">and thus validate its suitability for a particular operation.</span><br></pre></td></tr></table></figure></p>
<p>静态类型可以严格的保证数据完整性，动态类型牺牲了这种完整性，但是给予了更多的灵活性，例如id，而且通过对象的introspection特性，开发者依然可以在运行时验证一个对象的类型。</p>
<h3 id="introspection："><a href="#introspection：" class="headerlink" title="introspection："></a>introspection：</h3><p>1.首先是Class类型：<br>    •    Class class = [NSObject class]; // 通过类名得到对应的Class动态类型<br>    •    Class class = [obj class]; // 通过实例对象得到对应的Class动态类型<br>    •    if([obj1 class] == [obj2 class]) // 判断是不是相同类型的实例<br>2.Class动态类型和类名字符串的相互转换：<br>    •    NSClassFromString(@”NSObject”); // 由类名字符串得到Class动态类型<br>    •    NSStringFromClass([NSObject class]); // 由类名的动态类型得到类名字符串<br>    •    NSStringFromClass([obj class]); // 由对象的动态类型得到类名字符串<br>3.判断对象是否属于某种动态类型：<br>    •    -(BOOL)isKindOfClass:class // 判断某个对象是否是动态类型class的实例或其子类的实例<br>    •    -(BOOL)isMemberOfClass:class // 与isKindOfClass不同的是，这里只判断某个对象是否是class类型的实例，不放宽到其子类<br>4.判断类中是否有对应的方法：<br>    •    -(BOOL)respondsTosSelector:(SEL)selector // 类中是否有这个类方法<br>    •    -(BOOL)instancesRespondToSelector:(SEL)selector // 类中是否有这个实例方法<br>    上面两个方法都可以通过类名调用，前者判断类中是否有对应的类方法(通过‘+’修饰定义的方法)，后者判断类中是否有对应的实例方法(通过‘-’修饰定义的方法)。此外，前者respondsTosSelector函数还可以被类的实例对象调用，效果等同于直接用类名调用后者instancesRespondToSelector函数。 例如：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[1][Test instancesRespondToSelector:@selector(objFunc)];//YES</span><br><span class="line">  [2][Test instancesRespondToSelector:@selector(classFunc)];//NO</span><br><span class="line"></span><br><span class="line">  [3][Test respondsToSelector:@selector(objFunc)];//NO</span><br><span class="line">  [4][Test respondsToSelector:@selector(classFunc)];//YES</span><br><span class="line"></span><br><span class="line">  [5][test respondsToSelector:@selector(objFunc)];//YES</span><br><span class="line">  [6][test respondsToSelector:@selector(classFunc)];//NO</span><br></pre></td></tr></table></figure></p>
<p>5.方法名字符串和SEL类型的转换<br>    编译器会根据方法的名字和参数序列生成唯一标识改方法的ID,这个ID为SEL类型。到了运行时编译器通过SEL类型的ID来查找对应的方法，方法的名字和参数序列相同,那么它们的ID就都是相同的。另外，可以通过@select()指示符获得方法的ID。常用的方法如下：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SEL funcID = @select(func)；// 这个注册事件回调时常用，将方法转成SEL类型</span><br><span class="line">SEL funcID = NSSelectorFromString(@&quot;func&quot;); // 根据方法名得到方法标识</span><br><span class="line">NSString *funcName = NSStringFromSelector(funcID); // 根据SEL类型得到方法名字符串</span><br></pre></td></tr></table></figure></p>
<h2 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h2><p>动态绑定指的是方法的动态性，先来看官方定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Dynamic binding is determining the method to invoke at runtime instead of at </span><br><span class="line">compile time. Dynamic binding is also referred to as late binding. In Objective-C, </span><br><span class="line">all methods are resolved dynamically at runtime. The exact code executed is </span><br><span class="line">determined by both the method name (the selector) and the receiving object.</span><br><span class="line"></span><br><span class="line">Dynamic binding enables polymorphism. For example, consider a collection of</span><br><span class="line"> objects including Dog, Athlete, and ComputerSimulation. Each object has its own </span><br><span class="line"> implementation of a run method. In the following code fragment, the actual code </span><br><span class="line"> that should be executed by the expression [anObject run] is determined at </span><br><span class="line"> runtime. The runtime system uses the selector for the method run to identify the</span><br><span class="line">  appropriate method in whatever the class of anObject turns out to be.</span><br></pre></td></tr></table></figure></p>
<p>动态绑定的意思就是将方法的实现推迟到运行时再决定而不是编译期。在oc中，所有的方法都是运行时决定的，具体需要执行的代码需要通过方法名（selector）和接收者一起决定。</p>
<p>动态绑定实现了面向对象中多态这个特性。举例上面英文说的很详细了就不翻译了…代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSArray *anArray = [NSArray arrayWithObjects:aDog, anAthlete, aComputerSimulation, nil];</span><br><span class="line"></span><br><span class="line">id anObject = [anArray objectAtIndex:(random()/pow(2, 31)*3)];</span><br><span class="line"></span><br><span class="line">[anObject run];</span><br></pre></td></tr></table></figure></p>
<p>动态绑定是基于动态类型的，在运行时对象的类型确定后，那么对象的属性和方法也就确定了(包括类中原来的属性和方法以及运行时动态新加入的属性和方法)，这也就是所谓的动态绑定了。动态绑定的核心用法就该是在运行时动态的为类添加属性和方法，以及方法的最后处理或转发，主要用到C语言语法，因为涉及到运行时，因此要引入运行时头文件：objc/runtime.h。<br>消息转发可以参考effective oc 12条。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.csdn.net/cordova/article/details/53876682" target="_blank" rel="noopener">【iOS沉思录】Objective-C语言的动态性总结(编译时与运行时)</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/01/由NSString什么时候释放说起/" itemprop="url">
                  由NSString什么时候释放说起
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-03-01T18:11:40+08:00" content="2017-03-01">
              2017-03-01
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>最开始只是想试一试写在方法内部的局部变量释放时经不经过autoreleasepool。<br>例如，下图这样的代码。<br><img src="/pics/xxx.png" alt="nsobject 实验"><br>为了不影响对象本身的引用计数影响它的销毁过程，使用一个weak指针，不出所料的，打印出来了如下结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2017-03-01 18:25:05.117 Hello[72930:2179247] &lt;NSObject: 0x61000000a6e0&gt;</span><br><span class="line">2017-03-01 18:25:05.118 Hello[72930:2179247] (null)</span><br><span class="line">2017-03-01 18:25:05.150 Hello[72930:2179247] (null)</span><br></pre></td></tr></table></figure></p>
<p>但是这个实验如果换成NSString得到的则是完全不一样的结果。<br>如下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">__weak id reference = nil;</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    NSString *str = @&quot;123456&quot;;</span><br><span class="line">    reference = str;</span><br><span class="line">    NSLog(@&quot;%@&quot;, reference);</span><br><span class="line">    // str是一个autorelease对象，设置一个weak的引用来观察它</span><br><span class="line">&#125;</span><br><span class="line">- (void)viewWillAppear:(BOOL)animated &#123;</span><br><span class="line">    [super viewWillAppear:animated];</span><br><span class="line">    NSLog(@&quot;%@&quot;, reference);</span><br><span class="line">&#125;</span><br><span class="line">- (void)viewDidAppear:(BOOL)animated &#123;</span><br><span class="line">    [super viewDidAppear:animated];</span><br><span class="line">    NSLog(@&quot;%@&quot;, reference);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>打印出来的结果却是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2017-03-02 10:31:41.475 Hello[75799:2289076] 123456</span><br><span class="line">2017-03-02 10:31:41.475 Hello[75799:2289076] 123456</span><br><span class="line">2017-03-02 10:31:41.492 Hello[75799:2289076] 123456</span><br></pre></td></tr></table></figure></p>
<p>这个看上去也很好似乎也很好理解，NSString初始化的时候是存放在常量区的，所以没有释放嘛。</p>
<h2 id="深入研究"><a href="#深入研究" class="headerlink" title="深入研究"></a>深入研究</h2><p>为了观察对象的释放过程，我们在str赋值的地方加一个断点<br><img src="/pics/breakpoint.png" alt="break point"><br>走到该断点的时候通过lldb命令<code>watchpoint set variable str</code>来观察，可以看到str由0x0000000000000000变成0x00000001056b3250。<br><img src="/pics/赋值过程.png" alt="赋值过程"><br>然后一路点击<code>Continue program execution</code>，发现str会变成0x0000000000000000,控制台只打印了一次str的值，也就是说viewwillappear还没有执行，这点跟雷大博客(<a href="http://blog.leichunfeng.com/blog/2015/05/31/objective-c-autorelease-pool-implementation-principle/" target="_blank" rel="noopener">Objective-C Autorelease Pool 的实现原理</a>)中的略不一样，我猜是apple改了。<br><img src="/pics/释放1.png" alt="释放1"><br>然后看左侧的方法调用栈，会发现这个过程经过了<code>objc_store</code>,<code>AutoreleasePoolPage::pop(void *)</code>等函数通过autoreleasepool释放了。现在修改一下log语句。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define Log(_var) (&#123; NSString *name = @#_var; NSLog(@&quot;%@: %@ -&gt; %p : %@ &quot;, name, [_var class], _var, _var); &#125;)</span><br></pre></td></tr></table></figure></p>
<p>看了几个大神之前的博客，大都还打印了retainCount,但是今天这里研究的是arc，就不打印retainCount了。<br>执行如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">__weak id references = nil;</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    NSString *str = @&quot;123456789&quot;;</span><br><span class="line">    NSString *bstr = [NSString stringWithFormat:@&quot;123456789&quot;];</span><br><span class="line">    NSString *cstr = [str mutableCopy];</span><br><span class="line">    NSNumber *xnum = [NSNumber numberWithInteger:8];</span><br><span class="line">    references = cstr;</span><br><span class="line">    self.num = xnum;</span><br><span class="line">    Log(str);</span><br><span class="line">    Log(bstr);</span><br><span class="line">    Log(cstr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>得到打印结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2017-03-02 14:25:33.478 Hello[78655:2389611] str: __NSCFConstantString -&gt; 0x10b52c308 : 123456789 </span><br><span class="line">2017-03-02 14:25:33.478 Hello[78655:2389611] bstr: NSTaggedPointerString -&gt; 0xa1ea1f72bb30ab19 : 123456789 </span><br><span class="line">2017-03-02 14:25:33.478 Hello[78655:2389611] cstr: __NSCFString -&gt; 0x608000074d00 : 123456789</span><br></pre></td></tr></table></figure></p>
<p>可以看到这里其实是有三种String的,而references指向了cstr，此时在viewWillAppear和viewDidAppear里打印references得到的则是null。</p>
<h3 id="三种String"><a href="#三种String" class="headerlink" title="三种String"></a>三种String</h3><ul>
<li><strong>NSCFConstantString</strong>: 字符串常量，放在常量区，对其retain或者release不影响它的引用计数，程序结束后释放。用字面量语法创建出来的string就是这种，所以在出了viewDidLoad方法以后在其他地方也能打印出值，压根就没释放。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Tip:</span><br><span class="line">NSString *str = @“xxx”;其实创建了两个对象，指针str也是一个对象储存在栈内存中，由系统负责释放</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>NSTaggedPointerString</strong>: Tagged Point，标签指针，苹果在64位环境下对NSString和NSNumber做的一些优化，简单来说就是把对象的内容存放在了指针里，这样就不需要在堆内存里在开辟一块空间存放对象了，一般用来优化长度较小的内容。关于标签指针的内容可以参考唐巧的介绍：<a href="http://www.infoq.com/cn/articles/deep-understanding-of-tagged-pointer" target="_blank" rel="noopener">深入理解Tagged Pointer</a></p>
<p>对于NSString，当非字面量的数字，英文字母字符串的长度小于等于9的时候会自动成为NSTaggedPointerString类型。代码中的<em>bstr</em>如果再加一位或者有中文在里面就是变成NSCFString。而NSTaggedPointerString也是不会释放的，它的内容就在本身的指针里，又没有对象释放个啥啊。所以如果把references的赋值代码改为</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">references = bstr;</span><br></pre></td></tr></table></figure>
<p>  在viewWillAppear和viewDidAppear中也是能打印出值来的。</p>
</li>
<li><strong>NSCFString</strong>: 这种string就和普通的对象很像了，储存在堆上，有正常的引用计数，需要程序员分配释放。所以<code>references = cstr</code>时，会打印出null，<code>cstr</code>出了方法作用域在runloop结束时就被autoreleasepool释放了。</li>
</ul>
<h3 id="stringWithFormat"><a href="#stringWithFormat" class="headerlink" title="stringWithFormat"></a>stringWithFormat</h3><p>到这里还是有问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">__weak id references = nil;</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">   </span><br><span class="line">    NSString *str = @&quot;12345678900&quot;;</span><br><span class="line">    NSString *bstr = [NSString stringWithFormat:@&quot;12345678900&quot;];</span><br><span class="line">    NSString *cstr = [str mutableCopy];</span><br><span class="line">    references = bstr; //1</span><br><span class="line">    // references = cstr;//2</span><br><span class="line">    Log(str);</span><br><span class="line">    Log(bstr);</span><br><span class="line">    Log(cstr);</span><br><span class="line">&#125;</span><br><span class="line">- (void)viewWillAppear:(BOOL)animated &#123;</span><br><span class="line">    [super viewWillAppear:animated];</span><br><span class="line">    NSLog(@&quot;%@&quot;, references);</span><br><span class="line">&#125;</span><br><span class="line">- (void)viewDidAppear:(BOOL)animated &#123;</span><br><span class="line">    [super viewDidAppear:animated];</span><br><span class="line">    NSLog(@&quot;%p&quot;, references);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据以上说法，当string超过10位数时，<code>bstr</code>和<code>cstr</code>都是NSCFString，可是两种情况viewWillAppear和viewDidAppear在打印的结果不一样。<br>bstr:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2017-03-02 17:27:12.637 Hello[81349:2493571] 12345678900</span><br><span class="line">2017-03-02 17:27:13.187 Hello[81349:2493571] 0x0</span><br></pre></td></tr></table></figure></p>
<p>cstr:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2017-03-02 17:28:40.768 Hello[81398:2494728] (null)</span><br><span class="line">2017-03-02 17:28:41.311 Hello[81398:2494728] 0x0</span><br></pre></td></tr></table></figure></p>
<p>根据太阳神<a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="noopener">黑幕背后的Autorelease</a>中的说法，是因为viewWillAppear和viewDidLoad在一个runloop中导致<code>bstr</code>在willappear中能打印出来值。而<code>cstr</code>由于来自于mutablecopy方法，被自己持有，并不会加入到autoreleasepool当中，文章最开始用NSObject做实验时也是这个道理。</p>
<p>所以，stringWithFormat这个工厂方法在返回值时会先把对象加入到最近的autoreleasepool当中。<br>查资料得知以 <code>alloc</code>, <code>copy</code>, <code>init</code>,<code>mutableCopy</code>和<code>new</code>这些方法打头的方法，返回的都是 retained return value，例如<code>[[NSString alloc] initWithFormat:]</code>，而其他的则是unretained return value，例如 <code>[NSString stringWithFormat:]</code>。对于前者调用者是要负责释放的，对于后者就不需要了。而且对于后者ARC会把对象的生命周期延长，这里文档中没说延长方式，我猜加入自动释放池是手段之一，确保调用者能拿到并且使用这个返回值，但是并不一定会使用 autorelease，在worst case 的情况下才可能会使用，因此调用者不能假设返回值真的就在 autorelease pool中，有的时候为了优化会直接拿到返回值，狮子头一书中有讲。从性能的角度，这种做法也是可以理解的。如果我们能够知道一个对象的生命周期最长应该有多长，也就没有必要使用 autorelease 了，直接使用 release 就可以。如果很多对象都使用 autorelease 的话，也会导致整个 pool 在 drain 的时候性能下降。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">When returning from such a function or method, ARC retains the value at the point of evaluation of the return statement, then leaves all local scopes, and then balances out the retain while ensuring that the value lives across the call boundary. In the worst case, this may involve an autorelease, but callers must not assume that the value is actually in the autorelease pool.</span><br><span class="line"></span><br><span class="line">ARC performs no extra mandatory work on the caller side, although it may elect to do something to shorten the lifetime of the returned value.</span><br></pre></td></tr></table></figure></p>
<p>也就是说通过工程方法得到的string生命周期被延长了，所以才会在viewWillAppear里依然可以打印出来。为了证实这一点，我们换成array来做个实验。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">__weak id references = nil;</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    NSObject *object = [NSObject new];</span><br><span class="line">    NSArray *arr = @[object]; //1</span><br><span class="line">    //NSArray *arr = [NSArray arrayWithObjects:object, nil]; //2</span><br><span class="line">    references = arr;</span><br><span class="line">&#125;</span><br><span class="line">- (void)viewWillAppear:(BOOL)animated &#123;</span><br><span class="line">    [super viewWillAppear:animated];</span><br><span class="line">    NSLog(@&quot;%@&quot;, references);</span><br><span class="line">&#125;</span><br><span class="line">- (void)viewDidAppear:(BOOL)animated &#123;</span><br><span class="line">    [super viewDidAppear:animated];</span><br><span class="line">    NSLog(@&quot;%p&quot;, references);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第一种情况通过字面量创建array，打印台输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2017-03-02 17:48:19.667 Hello[81612:2505809] (null)</span><br><span class="line">2017-03-02 17:48:20.216 Hello[81612:2505809] 0x0</span><br></pre></td></tr></table></figure></p>
<p>第二种情况通过工厂方法创建，打印台输出:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2017-03-02 17:50:04.964 Hello[81664:2507484] (</span><br><span class="line">    &quot;&lt;NSObject: 0x618000200480&gt;&quot;</span><br><span class="line">)</span><br><span class="line">2017-03-02 17:50:05.508 Hello[81664:2507484] 0x0</span><br></pre></td></tr></table></figure></p>
<p>可以看到通过工厂方法创建的array生命周期确实被延长了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1.NSCFString跟普通对象一样是可以释放的<br>2.NSString和NSArray的工厂方法可以延长对象的生命周期，但不一定是通过autorelease，有可能优化(同理，NSDictionary也是一样的，有兴趣的可以试一下)<br>3.NSArray的释放做了很多优化，释放时机是个谜，有空总结下。</p>
<p>##参考资料<br><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="noopener">黑幕背后的Autorelease</a><br><a href="http://blog.leichunfeng.com/blog/2015/05/31/objective-c-autorelease-pool-implementation-principle/" target="_blank" rel="noopener">Objective-C Autorelease Pool 的实现原理</a><br><a href="https://segmentfault.com/a/1190000004943276" target="_blank" rel="noopener">Objective-C 内存管理——你需要知道的一切</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/21/Effective OC 46：不要用dispatch_current_queue/" itemprop="url">
                  Effective OC 46：不要用dispatch_current_queue
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-21T14:24:06+08:00" content="2016-09-21">
              2016-09-21
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>国际惯例先说结论：dispatch_current_queue已经被废弃了，虽然可以继续使用，但是会出问题的，比如说，你以为dispatch_current_queue返回的是queueA，但是queueA是在queueB的block中执行，外层的queueB会死锁。</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>第一点是会造成简单的死锁，</p>
<p>如下代码：</p>
<pre><code>dispatch_sync(queueA,^{
    dispatch_sync(queueB, ^{
        dispatch_block_t block = ^{/*...*/};
        if(dispatch_get_current_queue() == queueA) {
            block();
        }else {
            dispatch_sync(queueA,block);
        }
    })
});
</code></pre><p>这段代码是有问题的，代码的原意是想要在queueA上执行这个block，但是一开始dispatch_sync的queueA又在等待block执行完，造成死锁。这种写法略装b，是为了死锁而死锁的写法，但是还有一种意象不到的情况会死锁（虽然见的也不多）。</p>
<p>第二点，就是结论中说的queueA是在queueB的block中执行，外层的queueB会死锁。</p>
<p>队列是有层级体系的，以effective oc里的举例来看（p182图6-4），队列B,C的target是A,那么B,C里的block会在队列A中串行执行，队列A,D的target是全局的并发队列，那么队列A,D里的block会并发执行，如果有多个核心可能还会开多个线程并行执行。队列的层级体系可以通过dispatch_set_target_queue来设置。</p>
<p>dispatch_set_target_queue官方文档的说法是：</p>
<blockquote>
<p>A dispatch queue’s priority is inherited from its target queue. Use the dispatch_get_global_queue function to obtain a suitable target queue of the desired priority.</p>
</blockquote>
<blockquote>
<p>If you submit a block to a serial queue, and the serial queue’s target queue is a different serial queue, that block is not invoked concurrently with blocks submitted to the target queue or to any other queue with that same target queue.</p>
</blockquote>
<blockquote>
<p><strong>Important</strong></p>
</blockquote>
<blockquote>
<p>If you modify the target queue for a queue, you must be careful to avoid creating cycles in the queue hierarchy.</p>
</blockquote>
<p>简单翻译过来就是：</p>
<p>disptach_set_target_queue两个作用：</p>
<ol>
<li>队列(queue)的优先级是继承自他的目标队列(target queue)</li>
<li>如果提交一个block到串行队列，这个串行队列的目标队列是另一个串行队列，这个block不会和目标队列里的其他block并发执行，而是按照提交顺序执行。</li>
</ol>
<p>文档里的说法其实和上文说的一样，这样的话，一个blockC如果是在队列c中执行，但是队列c又是在队列A的blockA中执行，这时blockC中get_current_queue拿到的是queueC,然后放心的去queueA中执行其它操作，但是此时queueA其实正在等待自己的blockA执行完成，而blockA又在等queueC的blockC执行完成，这个时候在queueA中执行其它操作就容易造成死锁。</p>
<p>最后，通过effective oc上给的例子来试验一下dispatch_set_target_queue和dispatch_get_specific。</p>
<pre><code>dispatch_queue_t queueA = dispatch_queue_create(&quot;bifangao.queueA&quot;, NULL);
dispatch_queue_t queueB = dispatch_queue_create(&quot;bifangao.queueB&quot;, NULL);
dispatch_set_target_queue(queueB, queueA);

static int kQueueSpecific;
CFStringRef queueSpecificValue = CFSTR(&quot;queueA&quot;);
dispatch_queue_set_specific(queueA, &amp;kQueueSpecific, (void*)queueSpecificValue,     (dispatch_function_t)CFRelease);


dispatch_sync(queueB, ^{
    dispatch_block_t block = ^{
        NSLog(@&quot;no deadlock&quot;);
    };
    CFStringRef retrievedValue = dispatch_get_specific(&amp;kQueueSpecific);
    if (retrievedValue) {
        block();
    }else{
        dispatch_sync(queueA, block);
    }
});
</code></pre><p>如果把第三行的dispatch_set_target注释掉，在下面的dispatch_sync中会拿不到retrievedValue走else里的语句，在queueA中执行block，但是如果set了target，是可以拿到retrievedValue，在queueB中执行block的,原因在于如果没有dispatch_set_target,当前代码在哪个队列中执行，就拿到哪个队列的specific，但是如果设置了目标队列，则可以顺着队列链找到queueA，继而拿到queueA的specific，最后在queueB中执行block。<br>原文：</p>
<blockquote>
<p>The misunderstanding here is that dispatch_get_specific doesn’t traverse the stack of nested queues, it traverses the queue targeting lineage. For instance, if you did this instead,</p>
</blockquote>
<p>出处：<a href="http://stackoverflow.com/questions/19833744/how-to-use-dispatch-queue-set-specific-and-dispatch-get-specific" target="_blank" rel="noopener">StackOverflow</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/14/iOS旋转屏幕和坐标系/" itemprop="url">
                  iOS旋转屏幕和坐标系
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-14T16:19:02+08:00" content="2016-07-14">
              2016-07-14
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h1><p>一般情况下我们手机是竖屏的，此时的坐标系如下：</p>
<p><img src="/pics/未命名.001.jpeg" alt="默认坐标系" title="默认坐标系"></p>
<p>ok，我们知道每个view有自己的坐标系，所以如果旋转白色的view（盖在UIWindow上的view），transform180度，坐标系会变成：</p>
<p><img src="/pics/未命名.002.jpeg" alt="旋转后的坐标系" title="旋转后的坐标系"></p>
<p>看上去天经地义对不对。</p>
<p>但是如果旋转device的话…</p>
<pre><code>[[UIDevice currentDevice] setValue:[NSNumber numberWithInteger:UIDeviceOrientationLandscapeLeft] forKey:@&quot;orientation&quot;];
</code></pre><p>可以看到屏幕会被旋转成横向，并且横向会多出空白部分，此时的坐标系：</p>
<p><img src="/pics/未命名.003.jpeg" alt="横向" title="横向"></p>
<p>可以看到这个时候屏幕是转过来的，坐标系还是从statusbar那里开始算的，坐标系的更改会对我们的subview的位置有影响，因为subview的frame并没有变化，所以在视觉上，他们就会变一个位置。</p>
<h1 id="旋转屏幕"><a href="#旋转屏幕" class="headerlink" title="旋转屏幕"></a>旋转屏幕</h1><p>那么旋转屏幕有什么思路，现在我们旋转上图中灰色的部分，并且让灰色部分铺满屏幕，分三种思路吧：</p>
<ol>
<li>旋转灰色的view，白色父view不动。</li>
<li>旋转整个父view或者uiwindow，带动子view</li>
<li>旋转device就好了</li>
</ol>
<p>需要注意的是旋转父view的话会让坐标系跟着转，子view可能会出现在你不想让它出现的位置。旋转device的话弹出的键盘会跟着旋转，其它的旋转方式则没有这个效果。<br>直接上代码好了。</p>
<p><a href="https://github.com/suhou/RotateScreen" target="_blank" rel="noopener">旋转屏幕demo</a></p>
<h1 id="隐藏statusbar"><a href="#隐藏statusbar" class="headerlink" title="隐藏statusbar"></a>隐藏statusbar</h1><p>最后，一般全屏的时候statusbar都是隐藏的，分享一段代码:</p>
<pre><code>- (void)showStatusBar {
 UIWindow *statusBarWindow = [(UIWindow *)[UIApplication sharedApplication] valueForKey:@&quot;statusBarWindow&quot;];
 CGRect frame = statusBarWindow.frame;
 frame.origin.y = 0;
 statusBarWindow.frame = frame;
}

- (void)hideStatusBar {
 UIWindow *statusBarWindow = [(UIWindow *)[UIApplication sharedApplication] valueForKey:@&quot;statusBarWindow&quot;];
 CGRect frame = statusBarWindow.frame;
 CGSize statuBarFrameSize = [UIApplication sharedApplication].statusBarFrame.size;
 frame.origin.y = -statuBarFrameSize.height;
 statusBarWindow.frame = frame;
}
</code></pre><p>好了今天就先到这吧。。剩下不想讲了烂尾就烂尾。。。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/01/装好nvm以后command not found/" itemprop="url">
                  装好nvm以后command not found
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-01T14:18:01+08:00" content="2016-07-01">
              2016-07-01
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>装好nvm，使用hexo搭建博客，吃个饭的功夫回来发现hexo指令不好使了，nvm也不好使了 ＝ ＝，报错</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-bash: nvm: command not found</span><br></pre></td></tr></table></figure>
<p>原以为是nvm被谁卸了，使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.25.4/install.sh | bash</span><br></pre></td></tr></table></figure>
<p>重新装，提示我已经装了。</p>
<p>oh…明白了…重跑是吧…<br>隧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.nvm/nvm.sh</span><br></pre></td></tr></table></figure>
<p>顺便检查下node版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -a ~/.nvm/versions/node</span><br></pre></td></tr></table></figure>
<p>最后我用的是4.4.5</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm use v4.4.5</span><br></pre></td></tr></table></figure>
<p>好了，又可以愉快的提交blog了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>
<p>妥妥的</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.png" alt="su">
          <p class="site-author-name" itemprop="name">su</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">12</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">su</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  
  

  

  

</body>
</html>
